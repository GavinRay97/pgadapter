{
  "commands": [
    {
      "input_pattern": "SELECT n\\.nspname as \"[^\"]*\",[ \n]+c\\.relname as \"[^\"]*\",[ \n]+CASE c\\.relkind (WHEN '.' THEN '[^']*' )+END as \"[^\"]*\",[ \n]+pg_catalog\\.pg_get_userbyid\\(c\\.relowner\\) as \"[^\"]*\"\nFROM pg_catalog\\.pg_class c[ \n]+LEFT JOIN pg_catalog\\.pg_namespace n ON n\\.oid = c\\.relnamespace\nWHERE c\\.relkind IN \\('r'(?:,'p')?,'v','m','S','f',''\\)[ \n]+AND n\\.nspname <> 'pg_catalog'[ \n]+AND (?:n\\.nspname <> 'information_schema'[ \n]+AND )?n\\.nspname !~ '\\^pg_toast'[ \n]+AND (?:n\\.nspname <> 'information_schema'[ \n]+AND )?pg_catalog\\.pg_table_is_visible\\(c\\.oid\\)\nORDER BY 1,2;$",
      "output_pattern": "SELECT t.table_schema as \"Schema\", t.table_name as \"Name\", 'table' as \"Type\", 'me' as \"Owner\" FROM information_schema.tables AS t WHERE t.table_schema = 'public';",
      "matcher_array": [],
      "blurb": "This command is equivalent to the PSQL \\d meta-command."
    },
    {
      "input_pattern": "^SELECT c\\.oid,[ \n]+n\\.nspname,[ \n]+c\\.relname\nFROM pg_catalog\\.pg_class c[ \n]+LEFT JOIN pg_catalog\\.pg_namespace n ON n\\.oid = c\\.relnamespace\nWHERE c\\.relname OPERATOR\\(pg_catalog\\.~\\) '\\^\\((?<tablename>.*)\\)\\$'[ \n]+AND pg_catalog\\.pg_table_is_visible\\(c\\.oid\\)\nORDER BY 2, 3;$",
      "output_pattern": "SELECT t.table_name as oid, 'public' as nspname, t.table_name as relname FROM information_schema.tables AS t WHERE t.table_schema='public' AND LOWER(t.table_name) = LOWER('%s');",
      "matcher_array": [
        "tablename"
      ],
      "blurb": "This command is equivalent to the PSQL \\d <param> meta-command. This command is split up among multiple parts, this being the first. Here we just fetch basic metadata used to fetch the table schema in earnest in the next step."
    },
    {
      "input_pattern": "^SELECT relchecks, relkind, relhasindex, relhasrules, reltriggers <> 0, false, false, relhasoids, (?:false as relispartition, )?'', ''\nFROM pg_catalog\\.pg_class WHERE oid = '.*';$",
      "output_pattern": "SELECT 0 as relcheck, 'r' as relkind, false as relhasindex, false as relhasrules, false as reltriggers, false as bool1, false as bool2, false as relhasoids, '' as str1, '' as str2;",
      "matcher_array": [],
      "blurb": "This command is equivalent to the PSQL \\d <param> meta-command. This command is split up among multiple parts, this being the second. Here normally would fetch catalogue metadata, but due to Spanner structure, we expect it to be static, and thus just hardcode it."
    },
    {
      "input_pattern": "^SELECT a\\.attname,[ \n]+pg_catalog\\.format_type\\(a\\.atttypid, a\\.atttypmod\\),[ \n]+\\(SELECT (substring\\()?pg_catalog\\.pg_get_expr\\(d\\.adbin, d\\.adrelid(?:, true)?\\)( for 128\\))?[ \n]+FROM pg_catalog\\.pg_attrdef d[ \n]+WHERE d\\.adrelid = a\\.attrelid AND d\\.adnum = a\\.attnum AND a\\.atthasdef\\),[ \n]+a\\.attnotnull,(?: a\\.attnum,)?[ \n]+NULL AS attcollation,[ \n]+(?:''::pg_catalog\\.char AS attidentity,[ \n]+''::pg_catalog\\.char AS attgenerated\n|  NULL AS indexdef,[ \n]+NULL AS attfdwoptions\n)?([ ]*''::pg_catalog.char AS attidentity)?[ \n]*FROM pg_catalog\\.pg_attribute a\nWHERE a\\.attrelid = '(?<tablename>.*)' AND a\\.attnum > 0 AND NOT a\\.attisdropped\nORDER BY a\\.attnum;$",
      "output_pattern": "SELECT t.column_name as attname, t.data_type as format_type, '' as substring, t.is_nullable = 'NO' as attnotnull, null::INTEGER as attcollation, null::INTEGER as indexdef, null::INTEGER as attfdwoptions FROM information_schema.columns AS t WHERE t.table_schema='public' AND t.table_name = '%s';",
      "matcher_array": [
        "tablename"
      ],
      "blurb": "This command is equivalent to the PSQL \\d <param> meta-command. This command is split up among multiple parts, this being the third. Here we fetch the actual schema."
    },
    {
      "input_pattern": "^SELECT c\\.oid::pg_catalog\\.regclass[ \n]+FROM pg_catalog\\.pg_class c, pg_catalog\\.pg_inherits i[ \n]+WHERE c\\.oid( )?=( )?i\\.inhparent AND i\\.inhrelid = '.*'[ \n]+(?:AND c\\.relkind != 'p')?[ \n]+(?:AND c\\.relkind != 'I')?[ \n]*ORDER BY inhseqno;$",
      "output_pattern": "SELECT 1 LIMIT 0;",
      "matcher_array": [],
      "blurb": "This command is equivalent to the PSQL \\d <param> meta-command. This command is split up among multiple parts, this being the fourth. The Spanner fetch does not require a similar step so we just hardcode it."
    },
    {
      "input_pattern": "^SELECT c\\.oid::pg_catalog\\.regclass(, c\\.relkind(, false AS inhdetachpending)?, NULL)?[ \n]+FROM pg_catalog\\.pg_class c, pg_catalog\\.pg_inherits i[ \n]+WHERE c\\.oid( )?=( )?i\\.inhrelid AND i\\.inhparent = '.*'[ \n]+ORDER BY c\\.relname;$",
      "output_pattern": "SELECT 1 LIMIT 0;",
      "matcher_array": [],
      "blurb": "This command is equivalent to the PSQL \\d <param> meta-command. This command is split up among multiple parts, this being the fifth. The Spanner fetch does not require a similar step so we just hardcode it."
    },
    {
      "input_pattern": "^SELECT n\\.nspname as \"[^\"]*\",[ \n]+c\\.relname as \"[^\"]*\",[ \n]+CASE c\\.relkind (WHEN '.' THEN '[^']*' )+END as \"[^\"]*\",[ \n]+pg_catalog\\.pg_get_userbyid\\(c\\.relowner\\) as \"[^\"]*\"\nFROM pg_catalog\\.pg_class c[ \n]+LEFT JOIN pg_catalog\\.pg_namespace n ON n\\.oid = c\\.relnamespace\nWHERE c\\.relkind IN \\('r'(?:,'p')?,''\\)[ \n]+AND n\\.nspname <> 'pg_catalog'[ \n]+AND (?:n\\.nspname <> 'information_schema'[ \n]+AND )?n\\.nspname !~ '\\^pg_toast'[ \n]+AND (?:n\\.nspname <> 'information_schema'[ \n]+AND )?pg_catalog\\.pg_table_is_visible\\(c\\.oid\\)\nORDER BY 1,2;$",
      "output_pattern": "SELECT * FROM information_schema.tables;",
      "matcher_array": [],
      "blurb": "This command is equivalent to the PSQL \\dt meta-command."
    },
    {
      "input_pattern": "^SELECT n\\.nspname as \"[^\"]*\",[ \n]+c\\.relname as \"[^\"]*\",[ \n]+CASE c\\.relkind (WHEN '.' THEN '[^']*' )+END as \"[^\"]*\",[ \n]+pg_catalog\\.pg_get_userbyid\\(c\\.relowner\\) as \"[^\"]*\"\nFROM pg_catalog\\.pg_class c[ \n]+LEFT JOIN pg_catalog\\.pg_namespace n ON n\\.oid = c\\.relnamespace\nWHERE c\\.relkind IN \\('r'(?:,'p')?(?:,'t')?,'s',''\\)[ \n]+AND (?:n\\.nspname !~ '\\^pg_toast'[ \n]+AND )?c\\.relname OPERATOR\\(pg_catalog\\.~\\) '\\^\\((?<tablename>.*)\\)\\$'[ \n]+AND pg_catalog\\.pg_table_is_visible\\(c\\.oid\\)\nORDER BY 1,2;$",
      "output_pattern": "SELECT * FROM information_schema.tables WHERE LOWER(table_name) = LOWER('%s');",
      "matcher_array": [
        "tablename"
      ],
      "blurb": "This command is equivalent to the PSQL \\dt <param> meta-command."
    },
    {
      "input_pattern": "^SELECT n\\.nspname as \"[^\"]*\",[ \n]+c\\.relname as \"[^\"]*\",[ \n]+CASE c\\.relkind (WHEN '.' THEN '[^']*' )+END as \"[^\"]*\",[ \n]+pg_catalog\\.pg_get_userbyid\\(c\\.relowner\\) as \"[^\"]*\",[ \n]+c2\\.relname as \"[^\"]*\"\nFROM pg_catalog\\.pg_class c[ \n]+LEFT JOIN pg_catalog\\.pg_namespace n ON n\\.oid = c\\.relnamespace[ \n]+LEFT JOIN pg_catalog\\.pg_index i ON i\\.indexrelid = c\\.oid[ \n]+LEFT JOIN pg_catalog\\.pg_class c2 ON i\\.indrelid = c2\\.oid\nWHERE c\\.relkind IN \\('i'(?:,'I')?,''\\)[ \n]+AND n\\.nspname <> 'pg_catalog'[ \n]+AND (?:n\\.nspname <> 'information_schema'[ \n]+AND )?n\\.nspname !~ '\\^pg_toast'[ \n]+AND (?:n\\.nspname <> 'information_schema'[ \n]+AND )?pg_catalog\\.pg_table_is_visible\\(c\\.oid\\)\nORDER BY 1,2;$",
      "output_pattern": "SELECT * FROM information_schema.indexes;",
      "matcher_array": [],
      "blurb": "This command is equivalent to the PSQL \\di meta-command."
    },
    {
      "input_pattern": "^SELECT n\\.nspname as \"[^\"]*\",[ \n]+c\\.relname as \"[^\"]*\",[ \n]+CASE c\\.relkind (WHEN '.' THEN '[^']*' )+END as \"[^\"]*\",[ \n]+pg_catalog\\.pg_get_userbyid\\(c\\.relowner\\) as \"[^\"]*\",[ \n]+c2\\.relname as \"[^\"]*\"\nFROM pg_catalog\\.pg_class c[ \n]+LEFT JOIN pg_catalog\\.pg_namespace n ON n\\.oid = c\\.relnamespace[ \n]+LEFT JOIN pg_catalog\\.pg_index i ON i\\.indexrelid = c\\.oid[ \n]+LEFT JOIN pg_catalog\\.pg_class c2 ON i\\.indrelid = c2\\.oid\nWHERE c\\.relkind IN \\('i'(?:,'I')?,'s',''\\)[ \n]+AND (?:n\\.nspname !~ '\\^pg_toast'[ \n]+AND )?c\\.relname OPERATOR\\(pg_catalog\\.~\\) '\\^\\((?<indexname>.*)\\)\\$'[ \n]+AND pg_catalog\\.pg_table_is_visible\\(c\\.oid\\)\nORDER BY 1,2;$",
      "output_pattern": "SELECT * FROM information_schema.indexes WHERE LOWER(index_name) = LOWER('%s');",
      "matcher_array": [
        "indexname"
      ],
      "blurb": "This command is equivalent to the PSQL \\di <param> meta-command."
    },
    {
      "input_pattern": "^SELECT n\\.nspname AS \"[^\"]*\",[ \n]+pg_catalog\\.pg_get_userbyid\\(n\\.nspowner\\) AS \"[^\"]*\"\nFROM pg_catalog\\.pg_namespace n\nWHERE n\\.nspname !~ '\\^pg_' AND n\\.nspname <> 'information_schema'\nORDER BY 1;$",
      "output_pattern": "SELECT * FROM information_schema.schemata;",
      "matcher_array": [],
      "blurb": "This command is equivalent to the PSQL \\dn meta-command."
    },
    {
      "input_pattern": "^SELECT n\\.nspname AS \"[^\"]*\",[ \n]+pg_catalog\\.pg_get_userbyid\\(n\\.nspowner\\) AS \"[^\"]*\"\nFROM pg_catalog\\.pg_namespace n\nWHERE n\\.nspname OPERATOR\\(pg_catalog\\.~\\) '\\^\\((?<schemaname>.*)\\)\\$'\nORDER BY 1;$",
      "output_pattern": "SELECT * FROM information_schema.schemata WHERE LOWER(schema_name) = LOWER('%s');",
      "matcher_array": [
        "schemaname"
      ],
      "blurb": "This command is equivalent to the PSQL \\dn <param> meta-command."
    },
    {
      "input_pattern": "^SELECT pg_catalog\\.quote_ident\\(c\\.relname\\) FROM pg_catalog\\.pg_class c WHERE c\\.relkind IN \\('r', 'S', 'v', 'm', 'f'(?:, 'p')?\\) AND substring\\(pg_catalog\\.quote_ident\\(c\\.relname\\),\\d+,\\d+\\)='(?<prefix>.*)' AND pg_catalog\\.pg_table_is_visible\\(c\\.oid\\) AND c\\.relnamespace <> \\(SELECT oid FROM pg_catalog\\.pg_namespace WHERE nspname = 'pg_catalog'\\)\nUNION\nSELECT pg_catalog\\.quote_ident\\(n\\.nspname\\) \\|\\| '\\.' FROM pg_catalog\\.pg_namespace n WHERE substring\\(pg_catalog\\.quote_ident\\(n\\.nspname\\) \\|\\| '\\.',\\d+,\\d+\\)='.*' AND \\(SELECT pg_catalog\\.count\\(\\*\\) FROM pg_catalog\\.pg_namespace WHERE substring\\(pg_catalog\\.quote_ident\\(nspname\\) \\|\\| '\\.',\\d+,\\d+\\) = substring\\('.*',\\d+,pg_catalog\\.length\\(pg_catalog\\.quote_ident\\(nspname\\)\\)\\+\\d+\\)\\) > \\d+\nUNION\nSELECT pg_catalog\\.quote_ident\\(n\\.nspname\\) \\|\\| '\\.' \\|\\| pg_catalog\\.quote_ident\\(c\\.relname\\) FROM pg_catalog\\.pg_class c, pg_catalog\\.pg_namespace n WHERE c\\.relnamespace = n\\.oid AND c\\.relkind IN \\('r', 'S', 'v', 'm', 'f'(?:, 'p')?\\) AND substring\\(pg_catalog\\.quote_ident\\(n\\.nspname\\) \\|\\| '\\.' \\|\\| pg_catalog\\.quote_ident\\(c\\.relname\\),\\d+,\\d+\\)='.*' AND substring\\(pg_catalog\\.quote_ident\\(n\\.nspname\\) \\|\\| '\\.',\\d+,\\d+\\) = substring\\('.*',1,pg_catalog\\.length\\(pg_catalog\\.quote_ident\\(n\\.nspname\\)\\)\\+\\d+\\) AND \\(SELECT pg_catalog\\.count\\(\\*\\) FROM pg_catalog\\.pg_namespace WHERE substring\\(pg_catalog\\.quote_ident\\(nspname\\) \\|\\| '\\.',\\d+,\\d+\\) = substring\\('.*',\\d+,pg_catalog\\.length\\(pg_catalog\\.quote_ident\\(nspname\\)\\)\\+\\d+\\)\\) = \\d+\nLIMIT \\d+$",
      "output_pattern": "SELECT table_name AS quote_ident FROM information_schema.tables WHERE table_schema = 'public' and STARTS_WITH(LOWER(table_name), LOWER('%s')) LIMIT 1000;",
      "matcher_array": [
        "prefix"
      ],
      "blurb": "Autocomplete: This replacement helps psql autocomplete table names in simple select queries."
    },
    {
      "input_pattern": "^SELECT pg_catalog\\.quote_ident\\(c\\.relname\\) FROM pg_catalog\\.pg_class c WHERE c\\.relkind IN \\('r', 'f', 'v'(?:, 'p')?\\) AND substring\\(pg_catalog\\.quote_ident\\(c\\.relname\\),\\d+,\\d+\\)='(?<prefix>.*)' AND pg_catalog\\.pg_table_is_visible\\(c\\.oid\\) AND c\\.relnamespace <> \\(SELECT oid FROM pg_catalog\\.pg_namespace WHERE nspname = 'pg_catalog'\\)\nUNION\nSELECT pg_catalog\\.quote_ident\\(n\\.nspname\\) \\|\\| '\\.' FROM pg_catalog\\.pg_namespace n WHERE substring\\(pg_catalog\\.quote_ident\\(n\\.nspname\\) \\|\\| '\\.',\\d+,\\d+\\)='(.*)' AND \\(SELECT pg_catalog\\.count\\(\\*\\) FROM pg_catalog\\.pg_namespace WHERE substring\\(pg_catalog\\.quote_ident\\(nspname\\) \\|\\| '\\.',\\d+,\\d+\\) = substring\\('(.*)',\\d+,pg_catalog\\.length\\(pg_catalog\\.quote_ident\\(nspname\\)\\)\\+\\d+\\)\\) > \\d+\nUNION\nSELECT pg_catalog\\.quote_ident\\(n\\.nspname\\) \\|\\| '\\.' \\|\\| pg_catalog\\.quote_ident\\(c\\.relname\\) FROM pg_catalog\\.pg_class c, pg_catalog\\.pg_namespace n WHERE c\\.relnamespace = n\\.oid AND c\\.relkind IN \\('r', 'f', 'v'(?:, 'p')?\\) AND substring\\(pg_catalog\\.quote_ident\\(n\\.nspname\\) \\|\\| '\\.' \\|\\| pg_catalog\\.quote_ident\\(c\\.relname\\),\\d+,\\d+\\)='(.*)' AND substring\\(pg_catalog\\.quote_ident\\(n\\.nspname\\) \\|\\| '\\.',\\d+,\\d+\\) = substring\\('(.*)',\\d+,pg_catalog\\.length\\(pg_catalog\\.quote_ident\\(n\\.nspname\\)\\)\\+\\d+\\) AND \\(SELECT pg_catalog\\.count\\(\\*\\) FROM pg_catalog\\.pg_namespace WHERE substring\\(pg_catalog\\.quote_ident\\(nspname\\) \\|\\| '\\.',\\d+,\\d+\\) = substring\\('(.*)',\\d+,pg_catalog\\.length\\(pg_catalog\\.quote_ident\\(nspname\\)\\)\\+\\d+\\)\\) = \\d+\nLIMIT \\d+$",
      "output_pattern": "SELECT table_name AS quote_ident FROM information_schema.tables WHERE table_schema = 'public' and STARTS_WITH(LOWER(table_name), LOWER('%s')) LIMIT 1000;",
      "matcher_array": [
        "prefix"
      ],
      "blurb": "Autocomplete: This replacement helps psql autocomplete table names in simple insert queries."
    },
    {
      "input_pattern": "^SELECT pg_catalog\\.quote_ident\\(attname\\)[ \n]+FROM pg_catalog\\.pg_attribute a, pg_catalog\\.pg_class c[ \n]+WHERE c\\.oid = a\\.attrelid[ \n]+AND a\\.attnum > \\d+[ \n]+AND NOT a\\.attisdropped[ \n]+AND substring\\(pg_catalog\\.quote_ident\\(attname\\),\\d+,\\d+\\)='(?<attrprefix>.*)'[ \n]+AND \\(pg_catalog\\.quote_ident\\(relname\\)='(?<tablename>.*)'[ \n]+OR '\"' \\|\\| relname \\|\\| '\"'='.*'\\)[ \n]+AND pg_catalog\\.pg_table_is_visible\\(c\\.oid\\)\nLIMIT 1000$",
      "output_pattern": "SELECT column_name AS quote_ident FROM information_schema.columns WHERE table_name = '%s' AND STARTS_WITH(LOWER(COLUMN_NAME), LOWER('%s')) LIMIT 1000;",
      "matcher_array": [
        "tablename",
        "attrprefix"
      ],
      "blurb": "Autocomplete: This replacement helps psql autocomplete attribute names in simple queries."
    },
    {
      "input_pattern": "^SELECT pg_catalog\\.quote_ident\\(c\\.relname\\) FROM pg_catalog\\.pg_class c WHERE substring\\(pg_catalog\\.quote_ident\\(c\\.relname\\),\\d+,\\d+\\)='(?<prefix>.*)' AND pg_catalog\\.pg_table_is_visible\\(c\\.oid\\) AND c\\.relnamespace <> \\(SELECT oid FROM pg_catalog\\.pg_namespace WHERE nspname = 'pg_catalog'\\)\nUNION\nSELECT pg_catalog\\.quote_ident\\(n\\.nspname\\) \\|\\| '\\.' FROM pg_catalog\\.pg_namespace n WHERE substring\\(pg_catalog\\.quote_ident\\(n\\.nspname\\) \\|\\| '\\.',\\d+,\\d+\\)='.*' AND \\(SELECT pg_catalog\\.count\\(\\*\\) FROM pg_catalog\\.pg_namespace WHERE substring\\(pg_catalog\\.quote_ident\\(nspname\\) \\|\\| '\\.',\\d+,\\d+\\) = substring\\('.*',\\d+,pg_catalog\\.length\\(pg_catalog\\.quote_ident\\(nspname\\)\\)\\+\\d+\\)\\) > \\d+\nUNION\nSELECT pg_catalog\\.quote_ident\\(n\\.nspname\\) \\|\\| '\\.' \\|\\| pg_catalog\\.quote_ident\\(c\\.relname\\) FROM pg_catalog\\.pg_class c, pg_catalog\\.pg_namespace n WHERE c\\.relnamespace = n\\.oid AND substring\\(pg_catalog\\.quote_ident\\(n\\.nspname\\) \\|\\| '\\.' \\|\\| pg_catalog\\.quote_ident\\(c\\.relname\\),\\d+,\\d+\\)='.*' AND substring\\(pg_catalog\\.quote_ident\\(n\\.nspname\\) \\|\\| '\\.',\\d+,\\d+\\) = substring\\('.*',\\d+,pg_catalog\\.length\\(pg_catalog\\.quote_ident\\(n\\.nspname\\)\\)\\+\\d+\\) AND \\(SELECT pg_catalog\\.count\\(\\*\\) FROM pg_catalog\\.pg_namespace WHERE substring\\(pg_catalog\\.quote_ident\\(nspname\\) \\|\\| '\\.',\\d+,\\d+\\) = substring\\('.*',\\d+,pg_catalog\\.length\\(pg_catalog\\.quote_ident\\(nspname\\)\\)\\+\\d+\\)\\) = \\d+\nLIMIT \\d+$",
      "output_pattern": "SELECT table_name AS quote_ident FROM information_schema.tables WHERE table_schema = 'public' AND STARTS_WITH(LOWER(table_name), LOWER('%s')) LIMIT 1000;",
      "matcher_array": [
        "prefix"
      ],
      "blurb": "Autocomplete: This replacement helps psql autocomplete the \\d <table> command."
    },
    {
      "input_pattern": "^SELECT pg_catalog\\.quote_ident\\(c\\.relname\\) FROM pg_catalog\\.pg_class c WHERE c\\.relkind IN \\('r', 'p'\\) AND substring\\(pg_catalog\\.quote_ident\\(c\\.relname\\),\\d+,\\d+\\)='(?<prefix>.*)' AND pg_catalog\\.pg_table_is_visible\\(c\\.oid\\) AND c\\.relnamespace <> \\(SELECT oid FROM pg_catalog\\.pg_namespace WHERE nspname = 'pg_catalog'\\)\nUNION\nSELECT pg_catalog\\.quote_ident\\(n\\.nspname\\) \\|\\| '\\.' FROM pg_catalog\\.pg_namespace n WHERE substring\\(pg_catalog\\.quote_ident\\(n\\.nspname\\) \\|\\| '\\.',\\d+,\\d+\\)='(.*) AND \\(SELECT pg_catalog\\.count\\(\\*\\) FROM pg_catalog\\.pg_namespace WHERE substring\\(pg_catalog\\.quote_ident\\(nspname\\) \\|\\| '\\.',\\d+,\\d+\\) = substring\\('(.*),\\d+,pg_catalog\\.length\\(pg_catalog\\.quote_ident\\(nspname\\)\\)\\+\\d+\\)\\) > \\d+\nUNION\nSELECT pg_catalog\\.quote_ident\\(n\\.nspname\\) \\|\\| '\\.' \\|\\| pg_catalog\\.quote_ident\\(c\\.relname\\) FROM pg_catalog\\.pg_class c, pg_catalog\\.pg_namespace n WHERE c\\.relnamespace = n\\.oid AND c\\.relkind IN \\('r', 'p'\\) AND substring\\(pg_catalog\\.quote_ident\\(n\\.nspname\\) \\|\\| '\\.' \\|\\| pg_catalog\\.quote_ident\\(c\\.relname\\),\\d+,\\d+\\)='(.*) AND substring\\(pg_catalog\\.quote_ident\\(n\\.nspname\\) \\|\\| '\\.',\\d+,\\d+\\) = substring\\('(.*),\\d+,pg_catalog\\.length\\(pg_catalog\\.quote_ident\\(n\\.nspname\\)\\)\\+\\d+\\) AND \\(SELECT pg_catalog\\.count\\(\\*\\) FROM pg_catalog\\.pg_namespace WHERE substring\\(pg_catalog\\.quote_ident\\(nspname\\) \\|\\| '\\.',\\d+,\\d+\\) = substring\\('(.*),\\d+,pg_catalog\\.length\\(pg_catalog\\.quote_ident\\(nspname\\)\\)\\+\\d+\\)\\) = \\d+\nLIMIT \\d+$",
      "output_pattern": "SELECT table_name AS quote_ident FROM INFORMATION_SCHEMA.TABLES WHERE STARTS_WITH(LOWER(table_name), LOWER('%s')) LIMIT 1000;",
      "matcher_array": [
        "prefix"
      ],
      "blurb": "Autocomplete: This replacement helps psql autocomplete the \\dt <table> command."
    },
    {
      "input_pattern": "^SELECT pg_catalog\\.quote_ident\\(c\\.relname\\) FROM pg_catalog\\.pg_class c WHERE c\\.relkind IN \\('i', 'I'\\) AND substring\\(pg_catalog\\.quote_ident\\(c\\.relname\\),\\d+,\\d+\\)='(?<prefix>.*)' AND pg_catalog\\.pg_table_is_visible\\(c\\.oid\\) AND c\\.relnamespace <> \\(SELECT oid FROM pg_catalog\\.pg_namespace WHERE nspname = 'pg_catalog'\\)\nUNION\nSELECT pg_catalog\\.quote_ident\\(n\\.nspname\\) \\|\\| '\\.' FROM pg_catalog\\.pg_namespace n WHERE substring\\(pg_catalog\\.quote_ident\\(n\\.nspname\\) \\|\\| '\\.',\\d+,\\d+\\)='(.*)' AND \\(SELECT pg_catalog\\.count\\(\\*\\) FROM pg_catalog\\.pg_namespace WHERE substring\\(pg_catalog\\.quote_ident\\(nspname\\) \\|\\| '\\.',\\d+,\\d+\\) = substring\\('(.*)',\\d+,pg_catalog\\.length\\(pg_catalog\\.quote_ident\\(nspname\\)\\)\\+\\d+\\)\\) > \\d+\nUNION\nSELECT pg_catalog\\.quote_ident\\(n\\.nspname\\) \\|\\| '\\.' \\|\\| pg_catalog\\.quote_ident\\(c\\.relname\\) FROM pg_catalog\\.pg_class c, pg_catalog\\.pg_namespace n WHERE c\\.relnamespace = n\\.oid AND c\\.relkind IN \\('i', 'I'\\) AND substring\\(pg_catalog\\.quote_ident\\(n\\.nspname\\) \\|\\| '\\.' \\|\\| pg_catalog\\.quote_ident\\(c\\.relname\\),\\d+,\\d+\\)='(.*)' AND substring\\(pg_catalog\\.quote_ident\\(n\\.nspname\\) \\|\\| '\\.',\\d+,\\d+\\) = substring\\('(.*)',\\d+,pg_catalog\\.length\\(pg_catalog\\.quote_ident\\(n\\.nspname\\)\\)\\+\\d+\\) AND \\(SELECT pg_catalog\\.count\\(\\*\\) FROM pg_catalog\\.pg_namespace WHERE substring\\(pg_catalog\\.quote_ident\\(nspname\\) \\|\\| '\\.',\\d+,\\d+\\) = substring\\('(.*)',\\d+,pg_catalog\\.length\\(pg_catalog\\.quote_ident\\(nspname\\)\\)\\+\\d+\\)\\) = \\d+\nLIMIT \\d+$",
      "output_pattern": "SELECT index_name AS quote_ident FROM INFORMATION_SCHEMA.INDEXES WHERE STARTS_WITH(LOWER(index_name), LOWER('%s')) LIMIT 1000;",
      "matcher_array": [
        "prefix"
      ],
      "blurb": "Autocomplete: This replacement helps psql autocomplete the \\di <index> command."
    },
    {
      "input_pattern": "SELECT pg_catalog\\.quote_ident\\(nspname\\) FROM pg_catalog\\.pg_namespace[ \n]+WHERE substring\\(pg_catalog\\.quote_ident\\(nspname\\),\\d+,\\d+\\)='(?<prefix>.*)'\nLIMIT \\d+",
      "output_pattern": "SELECT schema_name AS quote_ident FROM INFORMATION_SCHEMA.SCHEMATA WHERE STARTS_WITH(LOWER(schema_name), LOWER('%s')) LIMIT 1000;",
      "matcher_array": [
        "prefix"
      ],
      "blurb": "Autocomplete: This replacement helps psql autocomplete the \\dn <schema> command."
    },
    {
      "input_pattern": "^SELECT pg_catalog\\.set_config\\('search_path', '', false\\);$",
      "output_pattern": "SELECT ''::varchar as set_config;",
      "matcher_array": [],
      "blurb": "This command removes publicly-writable schemas from search_path\\."
    },
    {
      "input_pattern": "^SELECT pg_catalog\\.pg_is_in_recovery\\(\\)$",
      "output_pattern": "SELECT false::boolean as pg_is_in_recovery",
      "matcher_array": [],
      "blurb": "This command indicates that the server is not in recovery mode\\."
    },
    {
      "input_pattern": "^SET DATESTYLE = ISO$",
      "output_pattern": "SET READONLY = FALSE",
      "matcher_array": [],
      "blurb": "No-op"
    },
    {
      "input_pattern": "^SET INTERVALSTYLE = POSTGRES$",
      "output_pattern": "SET READONLY = FALSE",
      "matcher_array": [],
      "blurb": "No-op"
    },
    {
      "input_pattern": "^SET extra_float_digits TO 3$",
      "output_pattern": "SET READONLY = FALSE",
      "matcher_array": [],
      "blurb": "No-op"
    },
    {
      "input_pattern": "^SET synchronize_seqscans TO off$",
      "output_pattern": "SET READONLY = FALSE",
      "matcher_array": [],
      "blurb": "No-op"
    },
    {
      "input_pattern": "^SET statement_timeout = 0$",
      "output_pattern": "SET statement_timeout = NULL",
      "matcher_array": [],
      "blurb": "Remove statement timeout"
    },
    {
      "input_pattern": "^SET lock_timeout = 0$",
      "output_pattern": "SET READONLY = FALSE",
      "matcher_array": [],
      "blurb": "No-op"
    },
    {
      "input_pattern": "^SET idle_in_transaction_session_timeout = 0$",
      "output_pattern": "SET READONLY = FALSE",
      "matcher_array": [],
      "blurb": "No-op"
    },
    {
      "input_pattern": "^SET row_security = off$",
      "output_pattern": "SET READONLY = FALSE",
      "matcher_array": [],
      "blurb": "No-op"
    },
    {
      "input_pattern": "^SET TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ ONLY$",
      "output_pattern": "SET TRANSACTION READ ONLY",
      "matcher_array": [],
      "blurb": "Set transaction to read-only"
    },
    {
      "input_pattern": "^SELECT x\\.tableoid, x\\.oid, x\\.extname, n\\.nspname, x\\.extrelocatable, x\\.extversion, x\\.extconfig, x\\.extcondition FROM pg_extension x JOIN pg_namespace n ON n\\.oid = x\\.extnamespace$",
      "output_pattern": "SELECT 0::bigint AS tableoid, 0::bigint as oid, ''::varchar as extname, ''::varchar as nspname, false::boolean as extrelocatable, ''::varchar as extversion, ''::varchar as extconfig, ''::varchar as extcondition from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT n\\.tableoid, n\\.oid, n\\.nspname, \\(SELECT rolname FROM pg_catalog\\.pg_roles WHERE oid = nspowner\\) AS rolname, \\(SELECT pg_catalog\\.array_agg\\(acl ORDER BY row_n\\) FROM \\(SELECT acl, row_n FROM pg_catalog\\.unnest\\(coalesce\\(n\\.nspacl,pg_catalog\\.acldefault\\('n',n\\.nspowner\\)\\)\\) WITH ORDINALITY AS perm\\(acl,row_n\\) WHERE NOT EXISTS \\( SELECT 1 FROM pg_catalog\\.unnest\\(coalesce\\(pip\\.initprivs,pg_catalog\\.acldefault\\('n',n\\.nspowner\\)\\)\\) AS init\\(init_acl\\) WHERE acl = init_acl\\)\\) as foo\\) as nspacl, \\(SELECT pg_catalog\\.array_agg\\(acl ORDER BY row_n\\) FROM \\(SELECT acl, row_n FROM pg_catalog\\.unnest\\(coalesce\\(pip\\.initprivs,pg_catalog\\.acldefault\\('n',n\\.nspowner\\)\\)\\) WITH ORDINALITY AS initp\\(acl,row_n\\) WHERE NOT EXISTS \\( SELECT 1 FROM pg_catalog\\.unnest\\(coalesce\\(n\\.nspacl,pg_catalog\\.acldefault\\('n',n\\.nspowner\\)\\)\\) AS permp\\(orig_acl\\) WHERE acl = orig_acl\\)\\) as foo\\) as rnspacl, NULL as initnspacl, NULL as initrnspacl FROM pg_namespace n LEFT JOIN pg_init_privs pip ON \\(n\\.oid = pip\\.objoid AND pip\\.classoid = 'pg_namespace'::regclass AND pip\\.objsubid = 0\\)$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT c\\.tableoid, c\\.oid, c\\.relname, \\(SELECT pg_catalog\\.array_agg\\(acl ORDER BY row_n\\) FROM \\(SELECT acl, row_n FROM pg_catalog\\.unnest\\(coalesce\\(c\\.relacl,pg_catalog\\.acldefault\\(CASE WHEN c\\.relkind = 'S' THEN 's' ELSE 'r' END::\"char\",c\\.relowner\\)\\)\\) WITH ORDINALITY AS perm\\(acl,row_n\\) WHERE NOT EXISTS \\( SELECT 1 FROM pg_catalog\\.unnest\\(coalesce\\(pip\\.initprivs,pg_catalog\\.acldefault\\(CASE WHEN c\\.relkind = 'S' THEN 's' ELSE 'r' END::\"char\",c\\.relowner\\)\\)\\) AS init\\(init_acl\\) WHERE acl = init_acl\\)\\) as foo\\) AS relacl, \\(SELECT pg_catalog\\.array_agg\\(acl ORDER BY row_n\\) FROM \\(SELECT acl, row_n FROM pg_catalog\\.unnest\\(coalesce\\(pip\\.initprivs,pg_catalog\\.acldefault\\(CASE WHEN c\\.relkind = 'S' THEN 's' ELSE 'r' END::\"char\",c\\.relowner\\)\\)\\) WITH ORDINALITY AS initp\\(acl,row_n\\) WHERE NOT EXISTS \\( SELECT 1 FROM pg_catalog\\.unnest\\(coalesce\\(c\\.relacl,pg_catalog\\.acldefault\\(CASE WHEN c\\.relkind = 'S' THEN 's' ELSE 'r' END::\"char\",c\\.relowner\\)\\)\\) AS permp\\(orig_acl\\) WHERE acl = orig_acl\\)\\) as foo\\) as rrelacl, NULL AS initrelacl, NULL as initrrelacl, c\\.relkind, c\\.relnamespace, \\(SELECT rolname FROM pg_catalog\\.pg_roles WHERE oid = c\\.relowner\\) AS rolname, c\\.relchecks, c\\.relhastriggers, c\\.relhasindex, c\\.relhasrules, 'f'::bool AS relhasoids, c\\.relrowsecurity, c\\.relforcerowsecurity, c\\.relfrozenxid, c\\.relminmxid, tc\\.oid AS toid, tc\\.relfrozenxid AS tfrozenxid, tc\\.relminmxid AS tminmxid, c\\.relpersistence, c\\.relispopulated, c\\.relreplident, c\\.relpages, am\\.amname, CASE WHEN c\\.relkind = 'f' THEN \\(SELECT ftserver FROM pg_catalog\\.pg_foreign_table WHERE ftrelid = c\\.oid\\) ELSE 0 END AS foreignserver, CASE WHEN c\\.reloftype <> 0 THEN c\\.reloftype::pg_catalog\\.regtype ELSE NULL END AS reloftype, d\\.refobjid AS owning_tab, d\\.refobjsubid AS owning_col, \\(SELECT spcname FROM pg_tablespace t WHERE t\\.oid = c\\.reltablespace\\) AS reltablespace, array_remove\\(array_remove\\(c\\.reloptions,'check_option=local'\\),'check_option=cascaded'\\) AS reloptions, CASE WHEN 'check_option=local' = ANY \\(c\\.reloptions\\) THEN 'LOCAL'::text WHEN 'check_option=cascaded' = ANY \\(c\\.reloptions\\) THEN 'CASCADED'::text ELSE NULL END AS checkoption, tc\\.reloptions AS toast_reloptions, c\\.relkind = 'S' AND EXISTS \\(SELECT 1 FROM pg_depend WHERE classid = 'pg_class'::regclass AND objid = c\\.oid AND objsubid = 0 AND refclassid = 'pg_class'::regclass AND deptype = 'i'\\) AS is_identity_sequence, EXISTS \\(SELECT 1 FROM pg_attribute at LEFT JOIN pg_init_privs pip ON \\(c\\.oid = pip\\.objoid AND pip\\.classoid = 'pg_class'::regclass AND pip\\.objsubid = at\\.attnum\\)WHERE at\\.attrelid = c\\.oid AND \\(\\(SELECT pg_catalog\\.array_agg\\(acl ORDER BY row_n\\) FROM \\(SELECT acl, row_n FROM pg_catalog\\.unnest\\(coalesce\\(at\\.attacl,pg_catalog\\.acldefault\\('c',c\\.relowner\\)\\)\\) WITH ORDINALITY AS perm\\(acl,row_n\\) WHERE NOT EXISTS \\( SELECT 1 FROM pg_catalog\\.unnest\\(coalesce\\(pip\\.initprivs,pg_catalog\\.acldefault\\('c',c\\.relowner\\)\\)\\) AS init\\(init_acl\\) WHERE acl = init_acl\\)\\) as foo\\) IS NOT NULL OR \\(SELECT pg_catalog\\.array_agg\\(acl ORDER BY row_n\\) FROM \\(SELECT acl, row_n FROM pg_catalog\\.unnest\\(coalesce\\(pip\\.initprivs,pg_catalog\\.acldefault\\('c',c\\.relowner\\)\\)\\) WITH ORDINALITY AS initp\\(acl,row_n\\) WHERE NOT EXISTS \\( SELECT 1 FROM pg_catalog\\.unnest\\(coalesce\\(at\\.attacl,pg_catalog\\.acldefault\\('c',c\\.relowner\\)\\)\\) AS permp\\(orig_acl\\) WHERE acl = orig_acl\\)\\) as foo\\) IS NOT NULL OR NULL IS NOT NULL OR NULL IS NOT NULL\\)\\)AS changed_acl, pg_get_partkeydef\\(c\\.oid\\) AS partkeydef, c\\.relispartition AS ispartition, pg_get_expr\\(c\\.relpartbound, c\\.oid\\) AS partbound FROM pg_class c LEFT JOIN pg_depend d ON \\(c\\.relkind = 'S' AND d\\.classid = c\\.tableoid AND d\\.objid = c\\.oid AND d\\.objsubid = 0 AND d\\.refclassid = c\\.tableoid AND d\\.deptype IN \\('a', 'i'\\)\\) LEFT JOIN pg_class tc ON \\(c\\.reltoastrelid = tc\\.oid AND c\\.relkind <> 'p'\\) LEFT JOIN pg_am am ON \\(c\\.relam = am\\.oid\\) LEFT JOIN pg_init_privs pip ON \\(c\\.oid = pip\\.objoid AND pip\\.classoid = 'pg_class'::regclass AND pip\\.objsubid = 0\\) WHERE c\\.relkind in \\('r', 'S', 'v', 'c', 'm', 'f', 'p'\\) ORDER BY c\\.oid$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT p\\.tableoid, p\\.oid, p\\.proname, p\\.prolang, p\\.pronargs, p\\.proargtypes, p\\.prorettype, \\(SELECT pg_catalog\\.array_agg\\(acl ORDER BY row_n\\) FROM \\(SELECT acl, row_n FROM pg_catalog\\.unnest\\(coalesce\\(p\\.proacl,pg_catalog\\.acldefault\\('f',p\\.proowner\\)\\)\\) WITH ORDINALITY AS perm\\(acl,row_n\\) WHERE NOT EXISTS \\( SELECT 1 FROM pg_catalog\\.unnest\\(coalesce\\(pip\\.initprivs,pg_catalog\\.acldefault\\('f',p\\.proowner\\)\\)\\) AS init\\(init_acl\\) WHERE acl = init_acl\\)\\) as foo\\) AS proacl, \\(SELECT pg_catalog\\.array_agg\\(acl ORDER BY row_n\\) FROM \\(SELECT acl, row_n FROM pg_catalog\\.unnest\\(coalesce\\(pip\\.initprivs,pg_catalog\\.acldefault\\('f',p\\.proowner\\)\\)\\) WITH ORDINALITY AS initp\\(acl,row_n\\) WHERE NOT EXISTS \\( SELECT 1 FROM pg_catalog\\.unnest\\(coalesce\\(p\\.proacl,pg_catalog\\.acldefault\\('f',p\\.proowner\\)\\)\\) AS permp\\(orig_acl\\) WHERE acl = orig_acl\\)\\) as foo\\) AS rproacl, NULL AS initproacl, NULL AS initrproacl, p\\.pronamespace, \\(SELECT rolname FROM pg_catalog\\.pg_roles WHERE oid = p\\.proowner\\) AS rolname FROM pg_proc p LEFT JOIN pg_init_privs pip ON \\(p\\.oid = pip\\.objoid AND pip\\.classoid = 'pg_proc'::regclass AND pip\\.objsubid = 0\\) WHERE p\\.prokind <> 'a'\n\\s+AND NOT EXISTS \\(SELECT 1 FROM pg_depend WHERE classid = 'pg_proc'::regclass AND objid = p\\.oid AND deptype = 'i'\\)\n\\s+AND \\(\n\\s+pronamespace != \\(SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog'\\)\n\\s+OR EXISTS \\(SELECT 1 FROM pg_cast\n\\s+WHERE pg_cast\\.oid > 16383 \n\\s+AND p\\.oid = pg_cast\\.castfunc\\)\n\\s+OR EXISTS \\(SELECT 1 FROM pg_transform\n\\s+WHERE pg_transform\\.oid > 16383 AND \n\\s+\\(p\\.oid = pg_transform\\.trffromsql\n\\s+OR p\\.oid = pg_transform\\.trftosql\\)\\)\n\\s+OR p\\.proacl IS DISTINCT FROM pip\\.initprivs\\)$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT t\\.tableoid, t\\.oid, t\\.typname, t\\.typnamespace, \\(SELECT pg_catalog\\.array_agg\\(acl ORDER BY row_n\\) FROM \\(SELECT acl, row_n FROM pg_catalog\\.unnest\\(coalesce\\(t\\.typacl,pg_catalog\\.acldefault\\('T',t\\.typowner\\)\\)\\) WITH ORDINALITY AS perm\\(acl,row_n\\) WHERE NOT EXISTS \\( SELECT 1 FROM pg_catalog\\.unnest\\(coalesce\\(pip\\.initprivs,pg_catalog\\.acldefault\\('T',t\\.typowner\\)\\)\\) AS init\\(init_acl\\) WHERE acl = init_acl\\)\\) as foo\\) AS typacl, \\(SELECT pg_catalog\\.array_agg\\(acl ORDER BY row_n\\) FROM \\(SELECT acl, row_n FROM pg_catalog\\.unnest\\(coalesce\\(pip\\.initprivs,pg_catalog\\.acldefault\\('T',t\\.typowner\\)\\)\\) WITH ORDINALITY AS initp\\(acl,row_n\\) WHERE NOT EXISTS \\( SELECT 1 FROM pg_catalog\\.unnest\\(coalesce\\(t\\.typacl,pg_catalog\\.acldefault\\('T',t\\.typowner\\)\\)\\) AS permp\\(orig_acl\\) WHERE acl = orig_acl\\)\\) as foo\\) AS rtypacl, NULL AS inittypacl, NULL AS initrtypacl, \\(SELECT rolname FROM pg_catalog\\.pg_roles WHERE oid = t\\.typowner\\) AS rolname, t\\.typelem, t\\.typrelid, CASE WHEN t\\.typrelid = 0 THEN ' '::\"char\" ELSE \\(SELECT relkind FROM pg_class WHERE oid = t\\.typrelid\\) END AS typrelkind, t\\.typtype, t\\.typisdefined, t\\.typname\\[0\\] = '_' AND t\\.typelem != 0 AND \\(SELECT typarray FROM pg_type te WHERE oid = t\\.typelem\\) = t\\.oid AS isarray FROM pg_type t LEFT JOIN pg_init_privs pip ON \\(t\\.oid = pip\\.objoid AND pip\\.classoid = 'pg_type'::regclass AND pip\\.objsubid = 0\\)$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT l\\.tableoid, l\\.oid, l\\.lanname, l\\.lanpltrusted, l\\.lanplcallfoid, l\\.laninline, l\\.lanvalidator, \\(SELECT pg_catalog\\.array_agg\\(acl ORDER BY row_n\\) FROM \\(SELECT acl, row_n FROM pg_catalog\\.unnest\\(coalesce\\(l\\.lanacl,pg_catalog\\.acldefault\\('l',l\\.lanowner\\)\\)\\) WITH ORDINALITY AS perm\\(acl,row_n\\) WHERE NOT EXISTS \\( SELECT 1 FROM pg_catalog\\.unnest\\(coalesce\\(pip\\.initprivs,pg_catalog\\.acldefault\\('l',l\\.lanowner\\)\\)\\) AS init\\(init_acl\\) WHERE acl = init_acl\\)\\) as foo\\) AS lanacl, \\(SELECT pg_catalog\\.array_agg\\(acl ORDER BY row_n\\) FROM \\(SELECT acl, row_n FROM pg_catalog\\.unnest\\(coalesce\\(pip\\.initprivs,pg_catalog\\.acldefault\\('l',l\\.lanowner\\)\\)\\) WITH ORDINALITY AS initp\\(acl,row_n\\) WHERE NOT EXISTS \\( SELECT 1 FROM pg_catalog\\.unnest\\(coalesce\\(l\\.lanacl,pg_catalog\\.acldefault\\('l',l\\.lanowner\\)\\)\\) AS permp\\(orig_acl\\) WHERE acl = orig_acl\\)\\) as foo\\) AS rlanacl, NULL AS initlanacl, NULL AS initrlanacl, \\(SELECT rolname FROM pg_catalog\\.pg_roles WHERE oid = l\\.lanowner\\) AS lanowner FROM pg_language l LEFT JOIN pg_init_privs pip ON \\(l\\.oid = pip\\.objoid AND pip\\.classoid = 'pg_language'::regclass AND pip\\.objsubid = 0\\) WHERE l\\.lanispl ORDER BY l\\.oid$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT p\\.tableoid, p\\.oid, p\\.proname AS aggname, p\\.pronamespace AS aggnamespace, p\\.pronargs, p\\.proargtypes, \\(SELECT rolname FROM pg_catalog\\.pg_roles WHERE oid = p\\.proowner\\) AS rolname, \\(SELECT pg_catalog\\.array_agg\\(acl ORDER BY row_n\\) FROM \\(SELECT acl, row_n FROM pg_catalog\\.unnest\\(coalesce\\(p\\.proacl,pg_catalog\\.acldefault\\('f',p\\.proowner\\)\\)\\) WITH ORDINALITY AS perm\\(acl,row_n\\) WHERE NOT EXISTS \\( SELECT 1 FROM pg_catalog\\.unnest\\(coalesce\\(pip\\.initprivs,pg_catalog\\.acldefault\\('f',p\\.proowner\\)\\)\\) AS init\\(init_acl\\) WHERE acl = init_acl\\)\\) as foo\\) AS aggacl, \\(SELECT pg_catalog\\.array_agg\\(acl ORDER BY row_n\\) FROM \\(SELECT acl, row_n FROM pg_catalog\\.unnest\\(coalesce\\(pip\\.initprivs,pg_catalog\\.acldefault\\('f',p\\.proowner\\)\\)\\) WITH ORDINALITY AS initp\\(acl,row_n\\) WHERE NOT EXISTS \\( SELECT 1 FROM pg_catalog\\.unnest\\(coalesce\\(p\\.proacl,pg_catalog\\.acldefault\\('f',p\\.proowner\\)\\)\\) AS permp\\(orig_acl\\) WHERE acl = orig_acl\\)\\) as foo\\) AS raggacl, NULL AS initaggacl, NULL AS initraggacl FROM pg_proc p LEFT JOIN pg_init_privs pip ON \\(p\\.oid = pip\\.objoid AND pip\\.classoid = 'pg_proc'::regclass AND pip\\.objsubid = 0\\) WHERE p\\.prokind = 'a' AND \\(p\\.pronamespace != \\(SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog'\\) OR p\\.proacl IS DISTINCT FROM pip\\.initprivs\\)$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT tableoid, oid, oprname, oprnamespace, \\(SELECT rolname FROM pg_catalog\\.pg_roles WHERE oid = oprowner\\) AS rolname, oprkind, oprcode::oid AS oprcode FROM pg_operator$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT tableoid, oid, amname, amtype, amhandler::pg_catalog\\.regproc AS amhandler FROM pg_am$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT tableoid, oid, opcname, opcnamespace, \\(SELECT rolname FROM pg_catalog\\.pg_roles WHERE oid = opcowner\\) AS rolname FROM pg_opclass$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT tableoid, oid, opfname, opfnamespace, \\(SELECT rolname FROM pg_catalog\\.pg_roles WHERE oid = opfowner\\) AS rolname FROM pg_opfamily$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT tableoid, oid, prsname, prsnamespace, prsstart::oid, prstoken::oid, prsend::oid, prsheadline::oid, prslextype::oid FROM pg_ts_parser$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT tableoid, oid, tmplname, tmplnamespace, tmplinit::oid, tmpllexize::oid FROM pg_ts_template$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT tableoid, oid, dictname, dictnamespace, \\(SELECT rolname FROM pg_catalog\\.pg_roles WHERE oid = dictowner\\) AS rolname, dicttemplate, dictinitoption FROM pg_ts_dict$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT tableoid, oid, cfgname, cfgnamespace, \\(SELECT rolname FROM pg_catalog\\.pg_roles WHERE oid = cfgowner\\) AS rolname, cfgparser FROM pg_ts_config$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT f\\.tableoid, f\\.oid, f\\.fdwname, \\(SELECT rolname FROM pg_catalog\\.pg_roles WHERE oid = f\\.fdwowner\\) AS rolname, f\\.fdwhandler::pg_catalog\\.regproc, f\\.fdwvalidator::pg_catalog\\.regproc, \\(SELECT pg_catalog\\.array_agg\\(acl ORDER BY row_n\\) FROM \\(SELECT acl, row_n FROM pg_catalog\\.unnest\\(coalesce\\(f\\.fdwacl,pg_catalog\\.acldefault\\('F',f\\.fdwowner\\)\\)\\) WITH ORDINALITY AS perm\\(acl,row_n\\) WHERE NOT EXISTS \\( SELECT 1 FROM pg_catalog\\.unnest\\(coalesce\\(pip\\.initprivs,pg_catalog\\.acldefault\\('F',f\\.fdwowner\\)\\)\\) AS init\\(init_acl\\) WHERE acl = init_acl\\)\\) as foo\\) AS fdwacl, \\(SELECT pg_catalog\\.array_agg\\(acl ORDER BY row_n\\) FROM \\(SELECT acl, row_n FROM pg_catalog\\.unnest\\(coalesce\\(pip\\.initprivs,pg_catalog\\.acldefault\\('F',f\\.fdwowner\\)\\)\\) WITH ORDINALITY AS initp\\(acl,row_n\\) WHERE NOT EXISTS \\( SELECT 1 FROM pg_catalog\\.unnest\\(coalesce\\(f\\.fdwacl,pg_catalog\\.acldefault\\('F',f\\.fdwowner\\)\\)\\) AS permp\\(orig_acl\\) WHERE acl = orig_acl\\)\\) as foo\\) AS rfdwacl, NULL AS initfdwacl, NULL AS initrfdwacl, array_to_string\\(ARRAY\\(SELECT quote_ident\\(option_name\\) \\|\\| ' ' \\|\\| quote_literal\\(option_value\\) FROM pg_options_to_table\\(f\\.fdwoptions\\) ORDER BY option_name\\), E',\n    '\\) AS fdwoptions FROM pg_foreign_data_wrapper f LEFT JOIN pg_init_privs pip ON \\(f\\.oid = pip\\.objoid AND pip\\.classoid = 'pg_foreign_data_wrapper'::regclass AND pip\\.objsubid = 0\\)$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT f\\.tableoid, f\\.oid, f\\.srvname, \\(SELECT rolname FROM pg_catalog\\.pg_roles WHERE oid = f\\.srvowner\\) AS rolname, f\\.srvfdw, f\\.srvtype, f\\.srvversion, \\(SELECT pg_catalog\\.array_agg\\(acl ORDER BY row_n\\) FROM \\(SELECT acl, row_n FROM pg_catalog\\.unnest\\(coalesce\\(f\\.srvacl,pg_catalog\\.acldefault\\('S',f\\.srvowner\\)\\)\\) WITH ORDINALITY AS perm\\(acl,row_n\\) WHERE NOT EXISTS \\( SELECT 1 FROM pg_catalog\\.unnest\\(coalesce\\(pip\\.initprivs,pg_catalog\\.acldefault\\('S',f\\.srvowner\\)\\)\\) AS init\\(init_acl\\) WHERE acl = init_acl\\)\\) as foo\\) AS srvacl, \\(SELECT pg_catalog\\.array_agg\\(acl ORDER BY row_n\\) FROM \\(SELECT acl, row_n FROM pg_catalog\\.unnest\\(coalesce\\(pip\\.initprivs,pg_catalog\\.acldefault\\('S',f\\.srvowner\\)\\)\\) WITH ORDINALITY AS initp\\(acl,row_n\\) WHERE NOT EXISTS \\( SELECT 1 FROM pg_catalog\\.unnest\\(coalesce\\(f\\.srvacl,pg_catalog\\.acldefault\\('S',f\\.srvowner\\)\\)\\) AS permp\\(orig_acl\\) WHERE acl = orig_acl\\)\\) as foo\\) AS rsrvacl, NULL AS initsrvacl, NULL AS initrsrvacl, array_to_string\\(ARRAY\\(SELECT quote_ident\\(option_name\\) \\|\\| ' ' \\|\\| quote_literal\\(option_value\\) FROM pg_options_to_table\\(f\\.srvoptions\\) ORDER BY option_name\\), E',\n    '\\) AS srvoptions FROM pg_foreign_server f LEFT JOIN pg_init_privs pip ON \\(f\\.oid = pip\\.objoid AND pip\\.classoid = 'pg_foreign_server'::regclass AND pip\\.objsubid = 0\\)$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT d\\.oid, d\\.tableoid, \\(SELECT rolname FROM pg_catalog\\.pg_roles WHERE oid = d\\.defaclrole\\) AS defaclrole, d\\.defaclnamespace, d\\.defaclobjtype, \\(SELECT pg_catalog\\.array_agg\\(acl ORDER BY row_n\\) FROM \\(SELECT acl, row_n FROM pg_catalog\\.unnest\\(coalesce\\(defaclacl,pg_catalog\\.acldefault\\(CASE WHEN defaclnamespace = 0 THEN\\s+CASE WHEN defaclobjtype = 'S' THEN\\s+'s'::\\\"char\\\"\\s+ELSE defaclobjtype END ELSE NULL END,defaclrole\\)\\)\\) WITH ORDINALITY AS perm\\(acl,row_n\\) WHERE NOT EXISTS \\( SELECT 1 FROM pg_catalog\\.unnest\\(coalesce\\(pip\\.initprivs,pg_catalog\\.acldefault\\(CASE WHEN defaclnamespace = 0 THEN\\s+CASE WHEN defaclobjtype = 'S' THEN 's'::\\\"char\\\"\\s+ELSE defaclobjtype END ELSE NULL END,defaclrole\\)\\)\\) AS init\\(init_acl\\) WHERE acl = init_acl\\)\\) as foo\\) AS defaclacl, \\(SELECT pg_catalog\\.array_agg\\(acl ORDER BY row_n\\) FROM \\(SELECT acl, row_n FROM pg_catalog\\.unnest\\(coalesce\\(pip\\.initprivs,pg_catalog\\.acldefault\\(CASE WHEN defaclnamespace = 0 THEN\\s+CASE WHEN defaclobjtype = 'S' THEN 's'::\\\"char\\\"\\s+ELSE defaclobjtype END ELSE NULL END,defaclrole\\)\\)\\) WITH ORDINALITY AS initp\\(acl,row_n\\) WHERE NOT EXISTS \\( SELECT 1 FROM pg_catalog\\.unnest\\(coalesce\\(defaclacl,pg_catalog\\.acldefault\\(CASE WHEN defaclnamespace = 0 THEN\\s+CASE WHEN defaclobjtype = 'S'\\s+THEN\\s+'s'::\\\"char\\\"\\s+ELSE defaclobjtype\\s+END\\s+ELSE\\s+NULL\\s+END,defaclrole\\)\\)\\) AS permp\\(orig_acl\\) WHERE acl = orig_acl\\)\\) as foo\\) AS rdefaclacl, NULL AS initdefaclacl, NULL AS initrdefaclacl FROM pg_default_acl d LEFT JOIN pg_init_privs pip ON \\(d\\.oid = pip\\.objoid AND pip\\.classoid = 'pg_default_acl'::regclass AND pip\\.objsubid = 0\\)$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT tableoid, oid, collname, collnamespace, \\(SELECT rolname FROM pg_catalog\\.pg_roles WHERE oid = collowner\\) AS rolname FROM pg_collation$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT tableoid, oid, conname, connamespace, \\(SELECT rolname FROM pg_catalog\\.pg_roles WHERE oid = conowner\\) AS rolname FROM pg_conversion$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT tableoid, oid, castsource, casttarget, castfunc, castcontext, castmethod FROM pg_cast ORDER BY 3,4$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT tableoid, oid, trftype, trflang, trffromsql::oid, trftosql::oid FROM pg_transform ORDER BY 3,4$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT inhrelid, inhparent FROM pg_inherits$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT e\\.tableoid, e\\.oid, evtname, evtenabled, evtevent, \\(SELECT rolname FROM pg_catalog\\.pg_roles WHERE oid = evtowner\\) AS evtowner, array_to_string\\(array\\(select quote_literal\\(x\\)  from unnest\\(evttags\\) as t\\(x\\)\\), ', '\\) as evttags, e\\.evtfoid::regproc as evtfname FROM pg_event_trigger e ORDER BY e\\.oid$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT tableoid, oid, stxname, stxnamespace, \\(SELECT rolname FROM pg_catalog\\.pg_roles WHERE oid = stxowner\\) AS rolname, stxstattarget FROM pg_catalog\\.pg_statistic_ext$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT tableoid, oid, rulename, ev_class AS ruletable, ev_type, is_instead, ev_enabled FROM pg_rewrite ORDER BY oid$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT oid, tableoid, pol\\.polrelid, pol\\.polname, pol\\.polcmd, pol\\.polpermissive, CASE WHEN pol\\.polroles = '\\{0\\}' THEN NULL ELSE    pg_catalog\\.array_to_string\\(ARRAY\\(SELECT pg_catalog\\.quote_ident\\(rolname\\) from pg_catalog\\.pg_roles WHERE oid = ANY\\(pol\\.polroles\\)\\), ', '\\) END AS polroles, pg_catalog\\.pg_get_expr\\(pol\\.polqual, pol\\.polrelid\\) AS polqual, pg_catalog\\.pg_get_expr\\(pol\\.polwithcheck, pol\\.polrelid\\) AS polwithcheck FROM pg_catalog\\.pg_policy pol$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT p\\.tableoid, p\\.oid, p\\.pubname, \\(SELECT rolname FROM pg_catalog\\.pg_roles WHERE oid = p\\.pubowner\\) AS rolname, p\\.puballtables, p\\.pubinsert, p\\.pubupdate, p\\.pubdelete, p\\.pubtruncate, p\\.pubviaroot FROM pg_publication p$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT tableoid, oid, prpubid, prrelid FROM pg_catalog\\.pg_publication_rel$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT count\\(\\*\\) FROM pg_subscription WHERE subdbid = \\(SELECT oid FROM pg_database\\s+WHERE datname = current_database\\(\\)\\)$",
      "output_pattern": "SELECT 0::bigint",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^WITH RECURSIVE w AS \\( SELECT d1\\.objid, d2\\.refobjid, c2\\.relkind AS refrelkind FROM pg_depend d1 JOIN pg_class c1 ON c1\\.oid = d1\\.objid AND c1\\.relkind = 'm' JOIN pg_rewrite r1 ON r1\\.ev_class = d1\\.objid JOIN pg_depend d2 ON d2\\.classid = 'pg_rewrite'::regclass AND d2\\.objid = r1\\.oid AND d2\\.refobjid <> d1\\.objid JOIN pg_class c2 ON c2\\.oid = d2\\.refobjid AND c2\\.relkind IN \\('m','v'\\) WHERE d1\\.classid = 'pg_class'::regclass UNION SELECT w\\.objid, d3\\.refobjid, c3\\.relkind FROM w JOIN pg_rewrite r3 ON r3\\.ev_class = w\\.refobjid JOIN pg_depend d3 ON d3\\.classid = 'pg_rewrite'::regclass AND d3\\.objid = r3\\.oid AND d3\\.refobjid <> w\\.refobjid JOIN pg_class c3 ON c3\\.oid = d3\\.refobjid AND c3\\.relkind IN \\('m','v'\\) \\) SELECT 'pg_class'::regclass::oid AS classid, objid, refobjid FROM w WHERE refrelkind = 'm'$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT l\\.oid, \\(SELECT rolname FROM pg_catalog\\.pg_roles WHERE oid = l\\.lomowner\\) AS rolname, \\(SELECT pg_catalog\\.array_agg\\(acl ORDER BY row_n\\) FROM \\(SELECT acl, row_n FROM pg_catalog\\.unnest\\(coalesce\\(l\\.lomacl,pg_catalog\\.acldefault\\('L',l\\.lomowner\\)\\)\\) WITH ORDINALITY AS perm\\(acl,row_n\\) WHERE NOT EXISTS \\( SELECT 1 FROM pg_catalog\\.unnest\\(coalesce\\(pip\\.initprivs,pg_catalog\\.acldefault\\('L',l\\.lomowner\\)\\)\\) AS init\\(init_acl\\) WHERE acl = init_acl\\)\\) as foo\\) AS lomacl, \\(SELECT pg_catalog\\.array_agg\\(acl ORDER BY row_n\\) FROM \\(SELECT acl, row_n FROM pg_catalog\\.unnest\\(coalesce\\(pip\\.initprivs,pg_catalog\\.acldefault\\('L',l\\.lomowner\\)\\)\\) WITH ORDINALITY AS initp\\(acl,row_n\\) WHERE NOT EXISTS \\( SELECT 1 FROM pg_catalog\\.unnest\\(coalesce\\(l\\.lomacl,pg_catalog\\.acldefault\\('L',l\\.lomowner\\)\\)\\) AS permp\\(orig_acl\\) WHERE acl = orig_acl\\)\\) as foo\\) AS rlomacl, NULL AS initlomacl, NULL AS initrlomacl FROM pg_largeobject_metadata l LEFT JOIN pg_init_privs pip ON \\(l\\.oid = pip\\.objoid AND pip\\.classoid = 'pg_largeobject'::regclass AND pip\\.objsubid = 0\\)$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT classid, objid, refclassid, refobjid, deptype FROM pg_depend WHERE deptype != 'p' AND deptype != 'e'\nUNION ALL\nSELECT 'pg_opfamily'::regclass AS classid, amopfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amop o WHERE deptype NOT IN \\('p', 'e', 'i'\\) AND classid = 'pg_amop'::regclass AND objid = o\\.oid AND NOT \\(refclassid = 'pg_opfamily'::regclass AND amopfamily = refobjid\\)\nUNION ALL\nSELECT 'pg_opfamily'::regclass AS classid, amprocfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amproc p WHERE deptype NOT IN \\('p', 'e', 'i'\\) AND classid = 'pg_amproc'::regclass AND objid = p\\.oid AND NOT \\(refclassid = 'pg_opfamily'::regclass AND amprocfamily = refobjid\\)\nORDER BY 1,2$",
      "output_pattern": "SELECT 0::bigint from pg_catalog\\.pg_class where false",
      "matcher_array": [],
      "blurb": ""
    },
    {
      "input_pattern": "^SELECT pg_catalog\\.current_schemas\\(false\\)$",
      "output_pattern": "SELECT array[]::varchar[]",
      "matcher_array": [],
      "blurb": ""
    }
  ]
}
